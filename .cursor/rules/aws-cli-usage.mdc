---
alwaysApply: true
---

# AWS CLI Usage Guide

## Overview

This project uses AWS CLI for managing Lambda functions, API Gateway, and other AWS resources. Authentication uses SAML via Okta and expires after **1 hour**.

## Critical: Always Check Authentication First

**⚠️ IMPORTANT:** AWS authentication expires after 1 hour. **ALWAYS verify AWS CLI is working before running any AWS commands.**

### Quick Authentication Check

Before running any AWS commands, run this check:

```bash
export AWS_PROFILE=saml
aws sts get-caller-identity --no-verify-ssl 2>&1 | grep -q "UserId" && echo "✓ AWS CLI authenticated" || echo "✗ AWS CLI NOT authenticated - run: export AWS_PROFILE=saml"
```

If authentication fails, you'll need to re-authenticate (the user will need to do this manually via their Okta/SAML flow).

## Environment Setup

All AWS CLI commands in this project require:

```bash
export AWS_PROFILE=saml
export AWS_CA_BUNDLE=""
export PYTHONHTTPSVERIFY=0
```

These settings:
- Use the `saml` AWS profile (Okta authentication)
- Disable SSL verification (required for corporate proxy/VPN)
- Suppress Python SSL warnings

## AWS CLI Command Wrapper

When creating scripts that use AWS CLI, use this wrapper function to handle SSL and warnings:

```bash
# AWS CLI command wrapper to add --no-verify-ssl and filter warnings
aws_cmd() {
    aws "$@" --no-verify-ssl 2> >(grep -v "InsecureRequestWarning" >&2)
}
```

Then use `aws_cmd` instead of `aws`:

```bash
aws_cmd lambda get-function-configuration --function-name admin-handler --region us-west-2
```

## Common AWS Resources

### Lambda Functions
- **admin-handler**: `arn:aws:lambda:us-west-2:763903610969:function:admin-handler`
- **auth-handler**: `arn:aws:lambda:us-west-2:763903610969:function:auth-handler`

### API Gateway
- **API ID**: `qx7x0uioo1`
- **Region**: `us-west-2`
- **Stage**: `v1`
- **Base URL**: `https://qx7x0uioo1.execute-api.us-west-2.amazonaws.com/v1`

## Verification Before Running Commands

### Step 1: Check Authentication

```bash
export AWS_PROFILE=saml
aws sts get-caller-identity --no-verify-ssl
```

**Expected output:**
```json
{
    "UserId": "AROA...",
    "Account": "763903610969",
    "Arn": "arn:aws:sts::763903610969:assumed-role/..."
}
```

**If you get an error:** Authentication has expired. User needs to re-authenticate via Okta/SAML.

### Step 2: Test a Simple Command

```bash
export AWS_PROFILE=saml
export AWS_CA_BUNDLE=""
export PYTHONHTTPSVERIFY=0

# Test with a simple, read-only command
aws lambda get-function-configuration \
    --function-name admin-handler \
    --region us-west-2 \
    --no-verify-ssl \
    --query '[FunctionName,Runtime,Handler]' \
    --output table
```

**Expected output:** A table showing function configuration.

**If you get SSL errors:** The environment variables aren't set correctly.

**If you get permission errors:** Authentication might be expired or insufficient permissions.

## Best Practices

### 1. Always Check Auth First

Before any AWS operation, verify authentication:

```bash
# Quick check
aws sts get-caller-identity --no-verify-ssl 2>&1 | grep -q "UserId" || { echo "ERROR: Not authenticated"; exit 1; }
```

### 2. Use Read-Only Commands for Testing

Test authentication with read-only commands first:
- `aws lambda get-function-configuration` (read-only)
- `aws apigateway get-rest-api` (read-only)
- `aws logs tail` (read-only)

### 3. Handle SSL Warnings

Always use `--no-verify-ssl` and filter warnings:

```bash
aws_cmd() {
    aws "$@" --no-verify-ssl 2> >(grep -v "InsecureRequestWarning" >&2)
}
```

### 4. Check Command Success

After running AWS commands, check exit codes:

```bash
if [ $? -eq 0 ]; then
    echo "✓ Command succeeded"
else
    echo "✗ Command failed"
    exit 1
fi
```

## Common Commands

### Lambda Operations

#### Building and Deploying Lambdas

Each Lambda function directory contains build and deploy scripts:

- **Build script**: `build-lambda.sh` - Compiles TypeScript, packages dependencies, and creates a zip file
- **Deploy script**: `deploy-lambda-s3.sh` - Uploads the zip to S3 and updates the Lambda function code

**Example workflow:**
```bash
# Navigate to the lambda directory
cd lambdas/generate-url

# Build the lambda (compiles TypeScript, creates zip)
./build-lambda.sh

# Deploy the lambda (uploads to S3, updates function)
./deploy-lambda-s3.sh
```

**Available Lambda directories:**
- `lambdas/admin-handler/` - Admin operations Lambda
- `lambdas/auth-handler/` - Authentication Lambda
- `lambdas/generate-url/` - Sigma embed URL generation Lambda
- `lambdas/my-buys-handler/` - My Buys applet CRUD operations Lambda

All build and deploy scripts follow the same pattern and handle:
- TypeScript compilation
- Dependency packaging
- Shared module inclusion
- S3-based deployment (faster for large files)
- Automatic authentication checks

#### Lambda Management Commands

```bash
# Get Lambda configuration
aws_cmd lambda get-function-configuration \
    --function-name admin-handler \
    --region us-west-2

# Invoke Lambda directly (for testing)
aws_cmd lambda invoke \
    --function-name admin-handler \
    --region us-west-2 \
    --cli-binary-format raw-in-base64-out \
    --payload file://test-event.json \
    response.json

# Check Lambda permissions
aws_cmd lambda get-policy \
    --function-name admin-handler \
    --region us-west-2 \
    --query 'Policy' \
    --output text | jq '.'
```

### API Gateway Operations

```bash
# List all resources
aws_cmd apigateway get-resources \
    --rest-api-id qx7x0uioo1 \
    --region us-west-2 \
    --query 'items[*].[path,id]' \
    --output table

# Get method configuration
aws_cmd apigateway get-method \
    --rest-api-id qx7x0uioo1 \
    --resource-id <RESOURCE_ID> \
    --http-method GET \
    --region us-west-2

# Create deployment
aws_cmd apigateway create-deployment \
    --rest-api-id qx7x0uioo1 \
    --stage-name v1 \
    --region us-west-2 \
    --description "Deployment description"
```

### CloudWatch Logs

```bash
# Tail Lambda logs
aws_cmd logs tail /aws/lambda/admin-handler \
    --follow \
    --region us-west-2

# Get recent logs
aws_cmd logs tail /aws/lambda/admin-handler \
    --since 5m \
    --region us-west-2
```

## Error Handling

### Authentication Expired

**Symptoms:**
- `Unable to locate credentials`
- `The security token included in the request is expired`
- `An error occurred (ExpiredTokenException)`

**Solution:** User needs to re-authenticate via Okta/SAML.

### SSL Certificate Errors

**Symptoms:**
- `SSL validation failed`
- `certificate verify failed`

**Solution:** Ensure these are set:
```bash
export AWS_CA_BUNDLE=""
export PYTHONHTTPSVERIFY=0
```

And use `--no-verify-ssl` flag.

### Permission Denied

**Symptoms:**
- `AccessDenied`
- `User is not authorized to perform`

**Solution:** Check IAM permissions or verify authentication is for correct role.

## Script Template

When creating new AWS CLI scripts, use this template:

```bash
#!/bin/bash

# Set AWS profile and disable SSL verification
export AWS_PROFILE=saml
export AWS_CA_BUNDLE=""
export PYTHONHTTPSVERIFY=0

# AWS CLI command wrapper
aws_cmd() {
    aws "$@" --no-verify-ssl 2> >(grep -v "InsecureRequestWarning" >&2)
}

# Verify authentication before proceeding
echo "Checking AWS authentication..."
if ! aws_cmd sts get-caller-identity --query 'Account' --output text > /dev/null 2>&1; then
    echo "✗ ERROR: AWS CLI not authenticated"
    echo "   Please run: export AWS_PROFILE=saml"
    echo "   Then re-authenticate via Okta/SAML"
    exit 1
fi

echo "✓ AWS CLI authenticated"
echo ""

# Your script commands here...
```

## Granting Secrets Manager Permissions to Lambda Functions

When a Lambda function needs to read a secret from AWS Secrets Manager, you need to grant IAM permissions to the Lambda's execution role.

### Reusable Script

Use the reusable script at `lambdas/generate-url/grant-secret-permissions.sh`:

```bash
# Grant permission for a specific Lambda and secret
./lambdas/generate-url/grant-secret-permissions.sh \
    generateSigmaEmbedURL \
    "arn:aws:secretsmanager:us-west-2:*:secret:mobile-app/jwt-secret-papercranestaging-*" \
    us-west-2

# Or use defaults (generateSigmaEmbedURL, papercranestaging secret, us-west-2)
./lambdas/generate-url/grant-secret-permissions.sh
```

### Manual Process

If you need to grant permissions manually or understand the process:

1. **Find the Lambda's IAM role:**
```bash
ROLE_ARN=$(aws lambda get-function-configuration \
    --function-name generateSigmaEmbedURL \
    --region us-west-2 \
    --no-verify-ssl \
    --query 'Role' \
    --output text)

# Extract role name from ARN
ROLE_NAME=$(echo "$ROLE_ARN" | sed 's/.*\///')
```

2. **Find the IAM policy name:**
```bash
# List inline policies
aws iam list-role-policies \
    --role-name "$ROLE_NAME" \
    --no-verify-ssl \
    --output json

# Look for policies with "secret" in the name, or use the only policy if there's just one
```

3. **Get current policy document:**
```bash
aws iam get-role-policy \
    --role-name "$ROLE_NAME" \
    --policy-name "SecretsManagerAccess" \
    --no-verify-ssl \
    --output json | python3 -c "
import sys, json
data = json.load(sys.stdin)
print(json.dumps(data['PolicyDocument']))
"
```

4. **Update policy to add secret ARN:**
   - Parse the JSON policy document
   - Find the `secretsmanager:GetSecretValue` statement
   - Add the new secret ARN to the `Resource` array
   - Update the policy using `aws iam put-role-policy`

### Important Learnings

#### 1. Heredoc Stdin Issue

**Problem:** When piping data to a Python script using heredoc, the heredoc takes precedence over stdin, causing `sys.stdin` to be empty.

**Solution:** Pass data via environment variables instead:

```bash
# ❌ This doesn't work - heredoc takes precedence over pipe
UPDATED_POLICY=$(echo "$POLICY_DOC" | python3 << 'PYTHON_SCRIPT'
import sys, json
policy = json.load(sys.stdin)  # This will be empty!
PYTHON_SCRIPT
)

# ✅ This works - use environment variable
UPDATED_POLICY=$(POLICY_DOC_JSON="$POLICY_DOC" python3 << 'PYTHON_SCRIPT'
import os, json
policy_json = os.environ.get('POLICY_DOC_JSON', '{}')
policy = json.loads(policy_json)  # This works!
PYTHON_SCRIPT
)
```

#### 2. Finding Lambda Roles Dynamically

Lambda roles can have different naming patterns. Always find the role dynamically:

```bash
# Get role ARN from Lambda configuration
ROLE_ARN=$(aws lambda get-function-configuration \
    --function-name "$FUNCTION_NAME" \
    --region "$REGION" \
    --query 'Role' \
    --output text)

# Extract role name (everything after the last /)
ROLE_NAME=$(echo "$ROLE_ARN" | sed 's/.*\///')
```

#### 3. Policy Name Discovery

IAM policies may have different names. Use a fallback strategy:

1. Look for policies with "secret" in the name
2. If only one inline policy exists, use that
3. Otherwise, list all policies and let user choose

#### 4. Secret ARN Format

Always use the wildcard suffix pattern for secret ARNs:
- ✅ `arn:aws:secretsmanager:us-west-2:*:secret:mobile-app/jwt-secret-papercranestaging-*`
- ❌ `arn:aws:secretsmanager:us-west-2:*:secret:mobile-app/jwt-secret-papercranestaging`

The `-*` suffix accounts for AWS automatically appending random characters to secret names.

### Example: Complete Permission Grant Script

```bash
#!/bin/bash
set -e

export AWS_PROFILE=saml
export AWS_CA_BUNDLE=""
export PYTHONHTTPSVERIFY=0

FUNCTION_NAME="${1:-generateSigmaEmbedURL}"
SECRET_ARN="${2:-arn:aws:secretsmanager:us-west-2:*:secret:mobile-app/jwt-secret-papercranestaging-*}"

# Find Lambda role
ROLE_ARN=$(aws lambda get-function-configuration \
    --function-name "$FUNCTION_NAME" \
    --region us-west-2 \
    --no-verify-ssl \
    --query 'Role' \
    --output text)
ROLE_NAME=$(echo "$ROLE_ARN" | sed 's/.*\///')

# Get policy document
POLICY_DOC=$(aws iam get-role-policy \
    --role-name "$ROLE_NAME" \
    --policy-name "SecretsManagerAccess" \
    --no-verify-ssl \
    --output json 2>/dev/null | python3 -c "
import sys, json
data = json.load(sys.stdin)
print(json.dumps(data['PolicyDocument']))
")

# Update policy (add secret ARN to resources)
UPDATED_POLICY=$(POLICY_DOC_JSON="$POLICY_DOC" SECRET_ARN="$SECRET_ARN" python3 << 'PYTHON_SCRIPT'
import json, os, sys
policy = json.loads(os.environ['POLICY_DOC_JSON'])
secret_arn = os.environ['SECRET_ARN']

for statement in policy['Statement']:
    if 'secretsmanager:GetSecretValue' in statement.get('Action', []):
        resources = statement.get('Resource', [])
        if isinstance(resources, str):
            resources = [resources]
        if secret_arn not in resources:
            resources.append(secret_arn)
            statement['Resource'] = resources
        break

print(json.dumps(policy))
PYTHON_SCRIPT
)

# Apply updated policy
aws iam put-role-policy \
    --role-name "$ROLE_NAME" \
    --policy-name "SecretsManagerAccess" \
    --policy-document "$UPDATED_POLICY" \
    --no-verify-ssl

echo "✅ Permission granted!"
```

## Notes

- **Authentication expires after 1 hour** - Always check before running commands
- **Corporate proxy/VPN** requires SSL verification to be disabled
- **All scripts should verify auth** before making AWS API calls
- **Use read-only commands** to test authentication first
- **Filter SSL warnings** to keep output clean
- **When using heredoc with pipes**, pass data via environment variables instead of stdin
- **Secret ARNs should use wildcard suffix** (`-*`) to account for AWS auto-appended characters
